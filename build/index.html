<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Tinqer - Type-safe LINQ-to-SQL query builder for TypeScript">
  <title>Getting Started - Tinqer Documentation</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <!-- Mobile Header -->
  <header class="mobile-header">
    <a href="index.html" class="mobile-logo">
      <img src="logo.svg" alt="Tinqer" class="logo-icon" />
      <span>Tinqer</span>
    </a>
    <button class="hamburger" id="hamburger" aria-label="Toggle menu">
      <span></span>
      <span></span>
      <span></span>
    </button>
  </header>

  <!-- Mobile Overlay -->
  <div class="mobile-overlay" id="overlay"></div>

  <!-- Sidebar Navigation -->
  <nav class="sidebar" id="sidebar">
    <div class="sidebar-header">
      <a href="index.html" class="logo">
        <img src="logo.svg" alt="Tinqer" class="logo-icon" />
        <span>Tinqer</span>
      </a>
      <p class="tagline">Type-safe LINQ-to-SQL for TypeScript</p>
      <a href="https://github.com/tinqerjs/tinqer" class="github-link" target="_blank" rel="noopener noreferrer">
        <svg width="20" height="20" viewBox="0 0 16 16" fill="currentColor">
          <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
        </svg>
        <span>GitHub</span>
      </a>
    </div>
    <ul class="nav-list">
  <li class="active"><a href="index.html">Getting Started</a></li>
  <li><a href="guide.html">Guide</a></li>
  <li><a href="api-reference.html">API Reference</a></li>
  <li><a href="adapters.html">Adapters</a></li>
  <li><a href="development.html">Development</a></li>
  <li><a href="architecture.html">Architecture</a></li>
</ul>
  </nav>

  <!-- Main Content -->
  <main class="content">
    <div class="breadcrumb"><span>Home</span></div>

    <div class="content-wrapper">
      <article class="markdown-body">
        <h1 id="tinqer" tabindex="-1"><a class="anchor" href="#tinqer" aria-hidden="true">#</a> Tinqer</h1>
<p>A type-safe query builder for TypeScript. Queries are expressed as inline arrow functions, parsed into an expression tree, and compiled into SQL for PostgreSQL or SQLite. The API is similar to DotNet’s LINQ-based frameworks.</p>
<h2 id="installation" tabindex="-1"><a class="anchor" href="#installation" aria-hidden="true">#</a> Installation</h2>
<p>Install the core library and adapter for your database:</p>
<pre class="hljs"><code><span class="hljs-comment"># Core library</span>
npm install @tinqerjs/tinqer

<span class="hljs-comment"># PostgreSQL adapter (pg-promise)</span>
npm install @tinqerjs/pg-promise-adapter

<span class="hljs-comment"># SQLite adapter (better-sqlite3)</span>
npm install @tinqerjs/better-sqlite3-adapter
</code></pre>
<h2 id="quick-start" tabindex="-1"><a class="anchor" href="#quick-start" aria-hidden="true">#</a> Quick Start</h2>
<h3 id="postgresql-example" tabindex="-1"><a class="anchor" href="#postgresql-example" aria-hidden="true">#</a> PostgreSQL Example</h3>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { createSchema } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@tinqerjs/tinqer&quot;</span>;
<span class="hljs-keyword">import</span> { executeSelect } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@tinqerjs/pg-promise-adapter&quot;</span>;
<span class="hljs-keyword">import</span> pgPromise <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;pg-promise&quot;</span>;

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Schema</span> {
  <span class="hljs-attr">users</span>: {
    <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;
    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
    <span class="hljs-attr">email</span>: <span class="hljs-built_in">string</span>;
    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
  };
}

<span class="hljs-keyword">const</span> pgp = <span class="hljs-title function_">pgPromise</span>();
<span class="hljs-keyword">const</span> db = <span class="hljs-title function_">pgp</span>(<span class="hljs-string">&quot;postgresql://user:pass@localhost:5432/mydb&quot;</span>);
<span class="hljs-keyword">const</span> schema = createSchema&lt;<span class="hljs-title class_">Schema</span>&gt;();

<span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> <span class="hljs-title function_">executeSelect</span>(
  db,
  schema,
  <span class="hljs-function">(<span class="hljs-params">q, <span class="hljs-attr">params</span>: { minAge: <span class="hljs-built_in">number</span> }</span>) =&gt;</span>
    q
      .<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;users&quot;</span>)
      .<span class="hljs-title function_">where</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> u.<span class="hljs-property">age</span> &gt;= params.<span class="hljs-property">minAge</span>)
      .<span class="hljs-title function_">orderBy</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> u.<span class="hljs-property">name</span>)
      .<span class="hljs-title function_">select</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> ({ <span class="hljs-attr">id</span>: u.<span class="hljs-property">id</span>, <span class="hljs-attr">name</span>: u.<span class="hljs-property">name</span> })),
  { <span class="hljs-attr">minAge</span>: <span class="hljs-number">18</span> },
);
<span class="hljs-comment">// results: [{ id: 1, name: &quot;Alice&quot; }, { id: 2, name: &quot;Bob&quot; }]</span>
</code></pre>
<p><strong>The same query works with SQLite</strong> - just change the adapter and database connection:</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> <span class="hljs-title class_">Database</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;better-sqlite3&quot;</span>;
<span class="hljs-keyword">import</span> { createSchema } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@tinqerjs/tinqer&quot;</span>;
<span class="hljs-keyword">import</span> { executeSelect } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@tinqerjs/better-sqlite3-adapter&quot;</span>;

<span class="hljs-comment">// Same schema definition</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Schema</span> {
  <span class="hljs-attr">users</span>: {
    <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;
    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
    <span class="hljs-attr">email</span>: <span class="hljs-built_in">string</span>;
    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
  };
}

<span class="hljs-keyword">const</span> db = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Database</span>(<span class="hljs-string">&quot;./data.db&quot;</span>);
<span class="hljs-keyword">const</span> schema = createSchema&lt;<span class="hljs-title class_">Schema</span>&gt;();

<span class="hljs-comment">// Identical query logic</span>
<span class="hljs-keyword">const</span> results = <span class="hljs-title function_">executeSelect</span>(
  db,
  schema,
  <span class="hljs-function">(<span class="hljs-params">q, <span class="hljs-attr">params</span>: { minAge: <span class="hljs-built_in">number</span> }</span>) =&gt;</span>
    q
      .<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;users&quot;</span>)
      .<span class="hljs-title function_">where</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> u.<span class="hljs-property">age</span> &gt;= params.<span class="hljs-property">minAge</span>)
      .<span class="hljs-title function_">orderBy</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> u.<span class="hljs-property">name</span>)
      .<span class="hljs-title function_">select</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> ({ <span class="hljs-attr">id</span>: u.<span class="hljs-property">id</span>, <span class="hljs-attr">name</span>: u.<span class="hljs-property">name</span> })),
  { <span class="hljs-attr">minAge</span>: <span class="hljs-number">18</span> },
);
<span class="hljs-comment">// results: [{ id: 1, name: &quot;Alice&quot; }, { id: 2, name: &quot;Bob&quot; }]</span>
</code></pre>
<h3 id="sql-generation-without-execution" tabindex="-1"><a class="anchor" href="#sql-generation-without-execution" aria-hidden="true">#</a> SQL Generation Without Execution</h3>
<p><strong><code>execute*</code> functions</strong> execute queries and return results. <strong><code>toSql</code> function</strong> generates SQL and parameters without executing - useful for debugging, logging, or custom execution:</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> {
  createSchema,
  defineSelect,
  defineInsert,
  defineUpdate,
  defineDelete,
} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@tinqerjs/tinqer&quot;</span>;
<span class="hljs-keyword">import</span> { toSql } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@tinqerjs/pg-promise-adapter&quot;</span>;

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Schema</span> {
  <span class="hljs-attr">users</span>: { <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> };
}

<span class="hljs-keyword">const</span> schema = createSchema&lt;<span class="hljs-title class_">Schema</span>&gt;();

<span class="hljs-comment">// SELECT - returns { sql, params }</span>
<span class="hljs-keyword">const</span> select = <span class="hljs-title function_">toSql</span>(
  <span class="hljs-title function_">defineSelect</span>(schema, <span class="hljs-function">(<span class="hljs-params">q, <span class="hljs-attr">params</span>: { minAge: <span class="hljs-built_in">number</span> }</span>) =&gt;</span>
    q.<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;users&quot;</span>).<span class="hljs-title function_">where</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> u.<span class="hljs-property">age</span> &gt;= params.<span class="hljs-property">minAge</span>),
  ),
  { <span class="hljs-attr">minAge</span>: <span class="hljs-number">18</span> },
);
<span class="hljs-comment">// select.sql: SELECT * FROM &quot;users&quot; WHERE &quot;age&quot; &gt;= $(minAge)</span>
<span class="hljs-comment">// select.params: { minAge: 18 }</span>

<span class="hljs-comment">// INSERT</span>
<span class="hljs-keyword">const</span> insert = <span class="hljs-title function_">toSql</span>(
  <span class="hljs-title function_">defineInsert</span>(schema, <span class="hljs-function">(<span class="hljs-params">q, <span class="hljs-attr">params</span>: { name: <span class="hljs-built_in">string</span>; age: <span class="hljs-built_in">number</span> }</span>) =&gt;</span>
    q.<span class="hljs-title function_">insertInto</span>(<span class="hljs-string">&quot;users&quot;</span>).<span class="hljs-title function_">values</span>({ <span class="hljs-attr">name</span>: params.<span class="hljs-property">name</span>, <span class="hljs-attr">age</span>: params.<span class="hljs-property">age</span> }),
  ),
  { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> },
);
<span class="hljs-comment">// insert.sql: INSERT INTO &quot;users&quot; (&quot;name&quot;, &quot;age&quot;) VALUES ($(name), $(age))</span>

<span class="hljs-comment">// UPSERT (PostgreSQL + SQLite)</span>
<span class="hljs-keyword">const</span> upsert = <span class="hljs-title function_">toSql</span>(
  <span class="hljs-title function_">defineInsert</span>(schema, <span class="hljs-function">(<span class="hljs-params">q, <span class="hljs-attr">params</span>: { id: <span class="hljs-built_in">number</span>; name: <span class="hljs-built_in">string</span>; age: <span class="hljs-built_in">number</span> }</span>) =&gt;</span>
    q
      .<span class="hljs-title function_">insertInto</span>(<span class="hljs-string">&quot;users&quot;</span>)
      .<span class="hljs-title function_">values</span>({ <span class="hljs-attr">id</span>: params.<span class="hljs-property">id</span>, <span class="hljs-attr">name</span>: params.<span class="hljs-property">name</span>, <span class="hljs-attr">age</span>: params.<span class="hljs-property">age</span> })
      .<span class="hljs-title function_">onConflict</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> u.<span class="hljs-property">id</span>)
      .<span class="hljs-title function_">doUpdateSet</span>(<span class="hljs-function">(<span class="hljs-params">_existing, excluded</span>) =&gt;</span> ({ <span class="hljs-attr">name</span>: excluded.<span class="hljs-property">name</span>, <span class="hljs-attr">age</span>: excluded.<span class="hljs-property">age</span> })),
  ),
  { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> },
);
<span class="hljs-comment">// upsert.sql: INSERT INTO &quot;users&quot; (...) VALUES (...) ON CONFLICT (&quot;id&quot;) DO UPDATE SET ...</span>

<span class="hljs-comment">// UPDATE</span>
<span class="hljs-keyword">const</span> update = <span class="hljs-title function_">toSql</span>(
  <span class="hljs-title function_">defineUpdate</span>(schema, <span class="hljs-function">(<span class="hljs-params">q, <span class="hljs-attr">params</span>: { newAge: <span class="hljs-built_in">number</span>; userId: <span class="hljs-built_in">number</span> }</span>) =&gt;</span>
    q
      .<span class="hljs-title function_">update</span>(<span class="hljs-string">&quot;users&quot;</span>)
      .<span class="hljs-title function_">set</span>({ <span class="hljs-attr">age</span>: params.<span class="hljs-property">newAge</span> })
      .<span class="hljs-title function_">where</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> u.<span class="hljs-property">id</span> === params.<span class="hljs-property">userId</span>),
  ),
  { <span class="hljs-attr">newAge</span>: <span class="hljs-number">31</span>, <span class="hljs-attr">userId</span>: <span class="hljs-number">1</span> },
);
<span class="hljs-comment">// update.sql: UPDATE &quot;users&quot; SET &quot;age&quot; = $(newAge) WHERE &quot;id&quot; = $(userId)</span>

<span class="hljs-comment">// DELETE</span>
<span class="hljs-keyword">const</span> del = <span class="hljs-title function_">toSql</span>(
  <span class="hljs-title function_">defineDelete</span>(schema, <span class="hljs-function">(<span class="hljs-params">q, <span class="hljs-attr">params</span>: { minAge: <span class="hljs-built_in">number</span> }</span>) =&gt;</span>
    q.<span class="hljs-title function_">deleteFrom</span>(<span class="hljs-string">&quot;users&quot;</span>).<span class="hljs-title function_">where</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> u.<span class="hljs-property">age</span> &lt; params.<span class="hljs-property">minAge</span>),
  ),
  { <span class="hljs-attr">minAge</span>: <span class="hljs-number">18</span> },
);
<span class="hljs-comment">// del.sql: DELETE FROM &quot;users&quot; WHERE &quot;age&quot; &lt; $(minAge)</span>
</code></pre>
<h2 id="core-features" tabindex="-1"><a class="anchor" href="#core-features" aria-hidden="true">#</a> Core Features</h2>
<h3 id="type-safe-query-building" tabindex="-1"><a class="anchor" href="#type-safe-query-building" aria-hidden="true">#</a> Type-Safe Query Building</h3>
<pre class="hljs"><code><span class="hljs-keyword">const</span> schema = createSchema&lt;<span class="hljs-title class_">Schema</span>&gt;();

<span class="hljs-comment">// Full TypeScript type inference</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">query</span> = (<span class="hljs-params">q</span>) =&gt;
  q
    .<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;users&quot;</span>)
    .<span class="hljs-title function_">where</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> u.<span class="hljs-property">age</span> &gt;= <span class="hljs-number">18</span> &amp;&amp; u.<span class="hljs-property">email</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;@company.com&quot;</span>))
    .<span class="hljs-title function_">orderBy</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> u.<span class="hljs-property">name</span>)
    .<span class="hljs-title function_">select</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> ({ <span class="hljs-attr">id</span>: u.<span class="hljs-property">id</span>, <span class="hljs-attr">name</span>: u.<span class="hljs-property">name</span>, <span class="hljs-attr">email</span>: u.<span class="hljs-property">email</span> }));

<span class="hljs-comment">// The query builder returns a Queryable whose result type is inferred as</span>
<span class="hljs-comment">// { id: number; name: string; email: string }</span>
</code></pre>
<h3 id="query-composition" tabindex="-1"><a class="anchor" href="#query-composition" aria-hidden="true">#</a> Query Composition</h3>
<p>Query plans are <strong>immutable and composable</strong> - you can chain operations onto plan handles to create reusable base queries and branch into specialized variations.</p>
<h4 id="chaining-operations-on-plans" tabindex="-1"><a class="anchor" href="#chaining-operations-on-plans" aria-hidden="true">#</a> Chaining Operations on Plans</h4>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { defineSelect } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@tinqerjs/tinqer&quot;</span>;
<span class="hljs-keyword">import</span> { toSql } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@tinqerjs/pg-promise-adapter&quot;</span>;

<span class="hljs-keyword">const</span> schema = createSchema&lt;<span class="hljs-title class_">Schema</span>&gt;();

<span class="hljs-comment">// Start with base query</span>
<span class="hljs-keyword">const</span> plan = <span class="hljs-title function_">defineSelect</span>(schema, <span class="hljs-function">(<span class="hljs-params">q</span>) =&gt;</span> q.<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;users&quot;</span>))
  .<span class="hljs-title function_">where</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> u.<span class="hljs-property">age</span> &gt; <span class="hljs-number">18</span>)
  .<span class="hljs-title function_">where</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> u.<span class="hljs-property">isActive</span>)
  .<span class="hljs-title function_">orderBy</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> u.<span class="hljs-property">name</span>)
  .<span class="hljs-title function_">select</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> ({ <span class="hljs-attr">id</span>: u.<span class="hljs-property">id</span>, <span class="hljs-attr">name</span>: u.<span class="hljs-property">name</span> }));

<span class="hljs-keyword">const</span> { sql, params } = <span class="hljs-title function_">toSql</span>(plan, {});
</code></pre>
<h4 id="reusable-base-queries" tabindex="-1"><a class="anchor" href="#reusable-base-queries" aria-hidden="true">#</a> Reusable Base Queries</h4>
<p>Plans are immutable - each operation returns a new plan without modifying the original. This enables creating base queries and branching:</p>
<pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">DeptParams</span> = { <span class="hljs-attr">dept</span>: <span class="hljs-built_in">number</span> };

<span class="hljs-comment">// Reusable base query</span>
<span class="hljs-keyword">const</span> usersInDept = <span class="hljs-title function_">defineSelect</span>(schema, <span class="hljs-function">(<span class="hljs-params">q, <span class="hljs-attr">p</span>: <span class="hljs-title class_">DeptParams</span></span>) =&gt;</span>
  q.<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;users&quot;</span>).<span class="hljs-title function_">where</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> u.<span class="hljs-property">departmentId</span> === p.<span class="hljs-property">dept</span>),
);

<span class="hljs-comment">// Branch 1: Active users only</span>
<span class="hljs-keyword">const</span> activeUsers = usersInDept
  .<span class="hljs-title function_">where</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> u.<span class="hljs-property">isActive</span> === <span class="hljs-literal">true</span>)
  .<span class="hljs-property">where</span>&lt;{ <span class="hljs-attr">minAge</span>: <span class="hljs-built_in">number</span> }&gt;(<span class="hljs-function">(<span class="hljs-params">u, p</span>) =&gt;</span> u.<span class="hljs-property">age</span> &gt;= p.<span class="hljs-property">minAge</span>);

<span class="hljs-comment">// Branch 2: Inactive users only</span>
<span class="hljs-keyword">const</span> inactiveUsers = usersInDept
  .<span class="hljs-title function_">where</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> u.<span class="hljs-property">isActive</span> === <span class="hljs-literal">false</span>)
  .<span class="hljs-property">where</span>&lt;{ <span class="hljs-attr">maxAge</span>: <span class="hljs-built_in">number</span> }&gt;(<span class="hljs-function">(<span class="hljs-params">u, p</span>) =&gt;</span> u.<span class="hljs-property">age</span> &lt;= p.<span class="hljs-property">maxAge</span>);

<span class="hljs-comment">// Execute branches with different parameters</span>
<span class="hljs-title function_">toSql</span>(activeUsers, { <span class="hljs-attr">dept</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">minAge</span>: <span class="hljs-number">25</span> });
<span class="hljs-title function_">toSql</span>(inactiveUsers, { <span class="hljs-attr">dept</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">maxAge</span>: <span class="hljs-number">65</span> });
</code></pre>
<h4 id="parameter-accumulation" tabindex="-1"><a class="anchor" href="#parameter-accumulation" aria-hidden="true">#</a> Parameter Accumulation</h4>
<p>Parameters from the builder function and chained operations are merged:</p>
<pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">BuilderParams</span> = { <span class="hljs-attr">baseAge</span>: <span class="hljs-built_in">number</span> };
<span class="hljs-keyword">type</span> <span class="hljs-title class_">ChainParams</span> = { <span class="hljs-attr">maxAge</span>: <span class="hljs-built_in">number</span> };

<span class="hljs-keyword">const</span> plan = <span class="hljs-title function_">defineSelect</span>(schema, <span class="hljs-function">(<span class="hljs-params">q, <span class="hljs-attr">p</span>: <span class="hljs-title class_">BuilderParams</span></span>) =&gt;</span>
  q.<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;users&quot;</span>).<span class="hljs-title function_">where</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> u.<span class="hljs-property">age</span> &gt; p.<span class="hljs-property">baseAge</span>),
).<span class="hljs-property">where</span>&lt;<span class="hljs-title class_">ChainParams</span>&gt;(<span class="hljs-function">(<span class="hljs-params">u, p</span>) =&gt;</span> u.<span class="hljs-property">age</span> &lt; p.<span class="hljs-property">maxAge</span>);

<span class="hljs-comment">// Must provide both parameter types</span>
<span class="hljs-title function_">toSql</span>(plan, { <span class="hljs-attr">baseAge</span>: <span class="hljs-number">18</span>, <span class="hljs-attr">maxAge</span>: <span class="hljs-number">65</span> });
</code></pre>
<p>Composition works with all operations: <code>defineSelect</code>, <code>defineInsert</code>, <code>defineUpdate</code>, <code>defineDelete</code>.</p>
<h3 id="row-filters" tabindex="-1"><a class="anchor" href="#row-filters" aria-hidden="true">#</a> Row Filters</h3>
<p>Row filters let you attach row-level predicates to a schema so that <strong>SELECT/UPDATE/DELETE</strong> automatically include them (useful for authorization scoping). This is enforced at plan finalization time and <strong>fails closed</strong> if you forget to bind context.</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { createSchema } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@tinqerjs/tinqer&quot;</span>;
<span class="hljs-keyword">import</span> { executeSelect } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@tinqerjs/pg-promise-adapter&quot;</span>;

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Schema</span> {
  <span class="hljs-attr">users</span>: { <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">orgId</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">email</span>: <span class="hljs-built_in">string</span> };
  <span class="hljs-attr">posts</span>: { <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">orgId</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span> };
}

<span class="hljs-keyword">type</span> <span class="hljs-title class_">ScopeContext</span> = { <span class="hljs-attr">orgId</span>: <span class="hljs-built_in">number</span> };

<span class="hljs-keyword">const</span> dangerousUnrestrictedSchema = createSchema&lt;<span class="hljs-title class_">Schema</span>&gt;();

<span class="hljs-keyword">const</span> rowFilteredSchema = dangerousUnrestrictedSchema.<span class="hljs-property">withRowFilters</span>&lt;<span class="hljs-title class_">ScopeContext</span>&gt;({
  <span class="hljs-attr">users</span>: <span class="hljs-function">(<span class="hljs-params">u, ctx</span>) =&gt;</span> u.<span class="hljs-property">orgId</span> === ctx.<span class="hljs-property">orgId</span>,
  <span class="hljs-attr">posts</span>: <span class="hljs-function">(<span class="hljs-params">p, ctx</span>) =&gt;</span> p.<span class="hljs-property">orgId</span> === ctx.<span class="hljs-property">orgId</span>,
});

<span class="hljs-keyword">const</span> schema = rowFilteredSchema.<span class="hljs-title function_">withContext</span>({ <span class="hljs-attr">orgId</span>: <span class="hljs-number">7</span> });

<span class="hljs-comment">// Any SELECT/UPDATE/DELETE using `schema` includes the row filter automatically.</span>
<span class="hljs-keyword">await</span> <span class="hljs-title function_">executeSelect</span>(db, schema, <span class="hljs-function">(<span class="hljs-params">q</span>) =&gt;</span> q.<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;posts&quot;</span>), {});
</code></pre>
<p>Notes:</p>
<ul>
<li>Filters must be provided for every table (set a table’s filter to <code>null</code> to opt out).</li>
<li>Row filters are not automatically applied to INSERT statements.</li>
<li>Unrestricted access is done by using the base schema (<code>dangerousUnrestrictedSchema</code>) directly.</li>
</ul>
<h3 id="joins" tabindex="-1"><a class="anchor" href="#joins" aria-hidden="true">#</a> Joins</h3>
<p>Tinqer mirrors LINQ semantics. Inner joins have a dedicated operator; left outer and cross joins follow the familiar <code>groupJoin</code>/<code>selectMany</code> patterns from C#.</p>
<h4 id="inner-join" tabindex="-1"><a class="anchor" href="#inner-join" aria-hidden="true">#</a> Inner Join</h4>
<pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Schema</span> {
  <span class="hljs-attr">users</span>: { <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">deptId</span>: <span class="hljs-built_in">number</span> };
  <span class="hljs-attr">departments</span>: { <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> };
}

<span class="hljs-keyword">const</span> schema = createSchema&lt;<span class="hljs-title class_">Schema</span>&gt;();

<span class="hljs-keyword">const</span> <span class="hljs-title function_">query</span> = (<span class="hljs-params">q</span>) =&gt;
  q
    .<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;users&quot;</span>)
    .<span class="hljs-title function_">join</span>(
      q.<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;departments&quot;</span>),
      <span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> user.<span class="hljs-property">deptId</span>,
      <span class="hljs-function">(<span class="hljs-params">department</span>) =&gt;</span> department.<span class="hljs-property">id</span>,
      <span class="hljs-function">(<span class="hljs-params">user, department</span>) =&gt;</span> ({
        <span class="hljs-attr">userName</span>: user.<span class="hljs-property">name</span>,
        <span class="hljs-attr">departmentName</span>: department.<span class="hljs-property">name</span>,
      }),
    )
    .<span class="hljs-title function_">orderBy</span>(<span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> row.<span class="hljs-property">userName</span>);
</code></pre>
<h4 id="left-outer-join" tabindex="-1"><a class="anchor" href="#left-outer-join" aria-hidden="true">#</a> Left Outer Join</h4>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-title function_">query</span> = (<span class="hljs-params">q</span>) =&gt;
  q
    .<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;users&quot;</span>)
    .<span class="hljs-title function_">groupJoin</span>(
      q.<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;departments&quot;</span>),
      <span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> user.<span class="hljs-property">deptId</span>,
      <span class="hljs-function">(<span class="hljs-params">department</span>) =&gt;</span> department.<span class="hljs-property">id</span>,
      <span class="hljs-function">(<span class="hljs-params">user, deptGroup</span>) =&gt;</span> ({ user, deptGroup }),
    )
    .<span class="hljs-title function_">selectMany</span>(
      <span class="hljs-function">(<span class="hljs-params">group</span>) =&gt;</span> group.<span class="hljs-property">deptGroup</span>.<span class="hljs-title function_">defaultIfEmpty</span>(),
      <span class="hljs-function">(<span class="hljs-params">group, department</span>) =&gt;</span> ({
        <span class="hljs-attr">user</span>: group.<span class="hljs-property">user</span>,
        department,
      }),
    )
    .<span class="hljs-title function_">select</span>(<span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> ({
      <span class="hljs-attr">userId</span>: row.<span class="hljs-property">user</span>.<span class="hljs-property">id</span>,
      <span class="hljs-attr">departmentName</span>: row.<span class="hljs-property">department</span> ? row.<span class="hljs-property">department</span>.<span class="hljs-property">name</span> : <span class="hljs-literal">null</span>,
    }));
</code></pre>
<h4 id="cross-join" tabindex="-1"><a class="anchor" href="#cross-join" aria-hidden="true">#</a> Cross Join</h4>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-title function_">query</span> = (<span class="hljs-params">q</span>) =&gt;
  q
    .<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;departments&quot;</span>)
    .<span class="hljs-title function_">selectMany</span>(
      <span class="hljs-function">() =&gt;</span> q.<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;users&quot;</span>),
      <span class="hljs-function">(<span class="hljs-params">department, user</span>) =&gt;</span> ({ department, user }),
    )
    .<span class="hljs-title function_">select</span>(<span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> ({
      <span class="hljs-attr">departmentId</span>: row.<span class="hljs-property">department</span>.<span class="hljs-property">id</span>,
      <span class="hljs-attr">userId</span>: row.<span class="hljs-property">user</span>.<span class="hljs-property">id</span>,
    }));
</code></pre>
<p>Right and full outer joins still require manual SQL, just as in LINQ-to-Objects.</p>
<h3 id="grouping-and-aggregation" tabindex="-1"><a class="anchor" href="#grouping-and-aggregation" aria-hidden="true">#</a> Grouping and Aggregation</h3>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-title function_">query</span> = (<span class="hljs-params">q</span>) =&gt;
  q
    .<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;orders&quot;</span>)
    .<span class="hljs-title function_">groupBy</span>(<span class="hljs-function">(<span class="hljs-params">o</span>) =&gt;</span> o.<span class="hljs-property">product_id</span>)
    .<span class="hljs-title function_">select</span>(<span class="hljs-function">(<span class="hljs-params">g</span>) =&gt;</span> ({
      <span class="hljs-attr">productId</span>: g.<span class="hljs-property">key</span>,
      <span class="hljs-attr">totalQuantity</span>: g.<span class="hljs-title function_">sum</span>(<span class="hljs-function">(<span class="hljs-params">o</span>) =&gt;</span> o.<span class="hljs-property">quantity</span>),
      <span class="hljs-attr">avgPrice</span>: g.<span class="hljs-title function_">avg</span>(<span class="hljs-function">(<span class="hljs-params">o</span>) =&gt;</span> o.<span class="hljs-property">price</span>),
      <span class="hljs-attr">orderCount</span>: g.<span class="hljs-title function_">count</span>(),
    }))
    .<span class="hljs-title function_">orderByDescending</span>(<span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> row.<span class="hljs-property">totalQuantity</span>);
</code></pre>
<h3 id="window-functions" tabindex="-1"><a class="anchor" href="#window-functions" aria-hidden="true">#</a> Window Functions</h3>
<p>Window functions enable calculations across rows related to the current row. Tinqer supports <code>ROW_NUMBER()</code>, <code>RANK()</code>, and <code>DENSE_RANK()</code> with optional partitioning and ordering.</p>
<pre class="hljs"><code><span class="hljs-comment">// Get top earner per department (automatically wrapped in subquery)</span>
<span class="hljs-keyword">const</span> topEarners = <span class="hljs-keyword">await</span> <span class="hljs-title function_">executeSelect</span>(
  db,
  schema,
  <span class="hljs-function">(<span class="hljs-params">q, params, h</span>) =&gt;</span>
    q
      .<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;employees&quot;</span>)
      .<span class="hljs-title function_">select</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> ({
        ...e,
        <span class="hljs-attr">rank</span>: h
          .<span class="hljs-title function_">window</span>(e)
          .<span class="hljs-title function_">partitionBy</span>(<span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> r.<span class="hljs-property">department</span>)
          .<span class="hljs-title function_">orderByDescending</span>(<span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> r.<span class="hljs-property">salary</span>)
          .<span class="hljs-title function_">rowNumber</span>(),
      }))
      .<span class="hljs-title function_">where</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e.<span class="hljs-property">rank</span> === <span class="hljs-number">1</span>), <span class="hljs-comment">// Filtering on window function result</span>
  {},
);

<span class="hljs-comment">// Generated SQL (automatically wrapped):</span>
<span class="hljs-comment">// SELECT * FROM (</span>
<span class="hljs-comment">//   SELECT *, ROW_NUMBER() OVER (PARTITION BY &quot;department&quot; ORDER BY &quot;salary&quot; DESC) AS &quot;rank&quot;</span>
<span class="hljs-comment">//   FROM &quot;employees&quot;</span>
<span class="hljs-comment">// ) AS &quot;employees&quot;</span>
<span class="hljs-comment">// WHERE &quot;rank&quot; = 1</span>
</code></pre>
<p><strong>Automatic Subquery Wrapping</strong>: Tinqer automatically detects when <code>where()</code> clauses reference window function columns and wraps the query in a subquery, since SQL doesn’t allow filtering on window functions at the same level where they’re defined.</p>
<p>See the <a href="docs/guide.md#8-window-functions">Window Functions Guide</a> for detailed examples of <code>RANK()</code>, <code>DENSE_RANK()</code>, complex ordering, and <a href="docs/guide.md#85-filtering-on-window-function-results">filtering on window results</a>.</p>
<h3 id="crud-operations" tabindex="-1"><a class="anchor" href="#crud-operations" aria-hidden="true">#</a> CRUD Operations</h3>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { createSchema } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@tinqerjs/tinqer&quot;</span>;
<span class="hljs-keyword">import</span> { executeInsert, executeUpdate, executeDelete } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@tinqerjs/pg-promise-adapter&quot;</span>;

<span class="hljs-keyword">const</span> schema = createSchema&lt;<span class="hljs-title class_">Schema</span>&gt;();

<span class="hljs-comment">// INSERT</span>
<span class="hljs-keyword">const</span> insertedRows = <span class="hljs-keyword">await</span> <span class="hljs-title function_">executeInsert</span>(
  db,
  schema,
  <span class="hljs-function">(<span class="hljs-params">q</span>) =&gt;</span>
    q.<span class="hljs-title function_">insertInto</span>(<span class="hljs-string">&quot;users&quot;</span>).<span class="hljs-title function_">values</span>({
      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>,
      <span class="hljs-attr">email</span>: <span class="hljs-string">&quot;alice@example.com&quot;</span>,
    }),
  {},
);

<span class="hljs-comment">// UPDATE with RETURNING</span>
<span class="hljs-keyword">const</span> inactiveUsers = <span class="hljs-keyword">await</span> <span class="hljs-title function_">executeUpdate</span>(
  db,
  schema,
  <span class="hljs-function">(<span class="hljs-params">q, <span class="hljs-attr">params</span>: { cutoffDate: <span class="hljs-built_in">Date</span> }</span>) =&gt;</span>
    q
      .<span class="hljs-title function_">update</span>(<span class="hljs-string">&quot;users&quot;</span>)
      .<span class="hljs-title function_">set</span>({ <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;inactive&quot;</span> })
      .<span class="hljs-title function_">where</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> u.<span class="hljs-property">lastLogin</span> &lt; params.<span class="hljs-property">cutoffDate</span>)
      .<span class="hljs-title function_">returning</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> u.<span class="hljs-property">id</span>),
  { <span class="hljs-attr">cutoffDate</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;2023-01-01&quot;</span>) },
);

<span class="hljs-comment">// UPDATE with column self-reference (increment counters, etc.)</span>
<span class="hljs-keyword">await</span> <span class="hljs-title function_">executeUpdate</span>(
  db,
  schema,
  <span class="hljs-function">(<span class="hljs-params">q, <span class="hljs-attr">params</span>: { userId: <span class="hljs-built_in">number</span> }</span>) =&gt;</span>
    q
      .<span class="hljs-title function_">update</span>(<span class="hljs-string">&quot;users&quot;</span>)
      .<span class="hljs-title function_">set</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> ({ <span class="hljs-attr">view_count</span>: u.<span class="hljs-property">view_count</span> + <span class="hljs-number">1</span> }))
      .<span class="hljs-title function_">where</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> u.<span class="hljs-property">id</span> === params.<span class="hljs-property">userId</span>),
  { <span class="hljs-attr">userId</span>: <span class="hljs-number">1</span> },
);

<span class="hljs-comment">// Tip: undefined values in .set() or .values() are ignored; explicit null sets NULL.</span>

<span class="hljs-comment">// DELETE</span>
<span class="hljs-keyword">const</span> deletedCount = <span class="hljs-keyword">await</span> <span class="hljs-title function_">executeDelete</span>(
  db,
  schema,
  <span class="hljs-function">(<span class="hljs-params">q</span>) =&gt;</span> q.<span class="hljs-title function_">deleteFrom</span>(<span class="hljs-string">&quot;users&quot;</span>).<span class="hljs-title function_">where</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> u.<span class="hljs-property">status</span> === <span class="hljs-string">&quot;deleted&quot;</span>),
  {},
);

<span class="hljs-comment">// SQLite note: executeInsert/executeUpdate ignore RETURNING clauses at runtime; run a follow-up SELECT if you need the affected rows.</span>
</code></pre>
<h3 id="parameters-and-auto-parameterisation" tabindex="-1"><a class="anchor" href="#parameters-and-auto-parameterisation" aria-hidden="true">#</a> Parameters and Auto-Parameterisation</h3>
<p>All literal values are automatically parameterized to prevent SQL injection:</p>
<pre class="hljs"><code><span class="hljs-comment">// External parameters via params object</span>
<span class="hljs-keyword">const</span> schema = createSchema&lt;<span class="hljs-title class_">Schema</span>&gt;();

<span class="hljs-keyword">const</span> sample = <span class="hljs-title function_">toSql</span>(
  <span class="hljs-title function_">defineSelect</span>(schema, <span class="hljs-function">(<span class="hljs-params">q, <span class="hljs-attr">params</span>: { minAge: <span class="hljs-built_in">number</span> }</span>) =&gt;</span>
    q.<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;users&quot;</span>).<span class="hljs-title function_">where</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> u.<span class="hljs-property">age</span> &gt;= params.<span class="hljs-property">minAge</span>),
  ),
  { <span class="hljs-attr">minAge</span>: <span class="hljs-number">18</span> },
);
<span class="hljs-comment">// SQL (PostgreSQL): SELECT * FROM &quot;users&quot; WHERE &quot;age&quot; &gt;= $(minAge)</span>
<span class="hljs-comment">// params: { minAge: 18 }</span>

<span class="hljs-comment">// Literals auto-parameterized automatically</span>
<span class="hljs-keyword">const</span> literals = <span class="hljs-title function_">toSql</span>(
  <span class="hljs-title function_">defineSelect</span>(schema, <span class="hljs-function">(<span class="hljs-params">q</span>) =&gt;</span> q.<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;users&quot;</span>).<span class="hljs-title function_">where</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> u.<span class="hljs-property">age</span> &gt;= <span class="hljs-number">18</span>)),
  {},
);
<span class="hljs-comment">// params: { __p1: 18 }</span>
</code></pre>
<h3 id="case-insensitive-string-operations" tabindex="-1"><a class="anchor" href="#case-insensitive-string-operations" aria-hidden="true">#</a> Case-Insensitive String Operations</h3>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { createSchema } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@tinqerjs/tinqer&quot;</span>;

<span class="hljs-keyword">const</span> schema = createSchema&lt;<span class="hljs-title class_">Schema</span>&gt;();

<span class="hljs-keyword">const</span> <span class="hljs-title function_">query</span> = (<span class="hljs-params">q, params, helpers</span>) =&gt;
  q.<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;users&quot;</span>).<span class="hljs-title function_">where</span>(<span class="hljs-function">(<span class="hljs-params">u</span>) =&gt;</span> helpers.<span class="hljs-property">functions</span>.<span class="hljs-title function_">icontains</span>(u.<span class="hljs-property">name</span>, params.<span class="hljs-property">searchTerm</span>)); <span class="hljs-comment">// Case-insensitive substring match</span>

<span class="hljs-comment">// PostgreSQL: WHERE LOWER(&quot;name&quot;) LIKE &#x27;%&#x27; || LOWER($(searchTerm)) || &#x27;%&#x27;</span>
<span class="hljs-comment">// SQLite: WHERE LOWER(&quot;name&quot;) LIKE &#x27;%&#x27; || LOWER(@searchTerm) || &#x27;%&#x27;</span>
</code></pre>
<h2 id="key-concepts" tabindex="-1"><a class="anchor" href="#key-concepts" aria-hidden="true">#</a> Key Concepts</h2>
<h3 id="query-lifecycle" tabindex="-1"><a class="anchor" href="#query-lifecycle" aria-hidden="true">#</a> Query Lifecycle</h3>
<ol>
<li><strong>Build Query</strong> - Construct fluent chain using <code>Queryable</code> API</li>
<li><strong>Parse Lambda</strong> - Lambda expressions are parsed into expression tree (never executed)</li>
<li><strong>Auto-Parameterize</strong> - Literal values extracted as parameters</li>
<li><strong>Generate SQL</strong> - Adapter converts expression tree to database-specific SQL</li>
</ol>
<h3 id="expression-support" tabindex="-1"><a class="anchor" href="#expression-support" aria-hidden="true">#</a> Expression Support</h3>
<p>Tinqer supports a focused set of JavaScript/TypeScript expressions:</p>
<ul>
<li><strong>Comparison</strong>: <code>===</code>, <code>!==</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code></li>
<li><strong>Logical</strong>: <code>&amp;&amp;</code>, <code>||</code>, <code>!</code></li>
<li><strong>Arithmetic</strong>: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></li>
<li><strong>String</strong>: <code>.includes()</code>, <code>.startsWith()</code>, <code>.endsWith()</code>, <code>.toLowerCase()</code>, <code>.toUpperCase()</code></li>
<li><strong>Null handling</strong>: <code>??</code> (null coalescing), <code>?.</code> (optional chaining)</li>
<li><strong>Arrays</strong>: <code>.includes()</code> for IN queries</li>
<li><strong>Helper functions</strong>: <code>helpers.functions.iequals()</code>, <code>helpers.functions.istartsWith()</code>, <code>helpers.functions.iendsWith()</code>, <code>helpers.functions.icontains()</code> (portable case-insensitive)</li>
<li><strong>Window functions</strong>: <code>helpers.window(row).partitionBy(...).orderBy(...).rowNumber()</code>, <code>helpers.window(row).rank()</code>, <code>helpers.window(row).denseRank()</code> with <code>orderByDescending()</code>, <code>thenBy()</code>, <code>thenByDescending()</code></li>
</ul>
<h2 id="database-support" tabindex="-1"><a class="anchor" href="#database-support" aria-hidden="true">#</a> Database Support</h2>
<h3 id="postgresql" tabindex="-1"><a class="anchor" href="#postgresql" aria-hidden="true">#</a> PostgreSQL</h3>
<ul>
<li>Native boolean type (<code>true</code>/<code>false</code>)</li>
<li>Case-insensitive helpers use <code>LOWER()</code> comparisons for portable SQL</li>
<li>Full JSONB support</li>
<li>Window functions: <code>ROW_NUMBER()</code>, <code>RANK()</code>, <code>DENSE_RANK()</code></li>
<li>Parameter placeholders: <code>$(name)</code> / <code>$(__p1)</code> (pg-promise format)</li>
</ul>
<h3 id="sqlite" tabindex="-1"><a class="anchor" href="#sqlite" aria-hidden="true">#</a> SQLite</h3>
<ul>
<li>Boolean values use INTEGER (0/1)</li>
<li>Case-insensitive via <code>LOWER()</code> function</li>
<li>JSON functions support</li>
<li>Window functions: <code>ROW_NUMBER()</code>, <code>RANK()</code>, <code>DENSE_RANK()</code> (requires SQLite 3.25+)</li>
<li>Parameter placeholders: <code>@name</code> / <code>@__p1</code></li>
</ul>
<p>See <a href="docs/adapters.md">Database Adapters</a> for detailed comparison.</p>
<h2 id="differences-from-net-linq-to-sql" tabindex="-1"><a class="anchor" href="#differences-from-net-linq-to-sql" aria-hidden="true">#</a> Differences from .NET LINQ to SQL</h2>
<ul>
<li>Lambdas cannot capture external variables; use params object</li>
<li>Join operations (<code>join</code>, <code>groupJoin</code>, <code>selectMany</code>) must be composed inside the defineSelect builder; they cannot be chained on plan handles</li>
<li>Left outer joins and cross joins supported via LINQ patterns (right/full joins still require manual SQL)</li>
<li>No deferred execution; SQL generated on demand</li>
<li>Grouping supports <code>count</code>, <code>sum</code>, <code>avg</code>, <code>min</code>, <code>max</code></li>
</ul>
<h2 id="documentation" tabindex="-1"><a class="anchor" href="#documentation" aria-hidden="true">#</a> Documentation</h2>
<ul>
<li><strong><a href="docs/guide.md">Query Operations Guide</a></strong> - Complete reference for all query operations, parameters, and CRUD</li>
<li><strong><a href="docs/api-reference.md">API Reference</a></strong> - Execution functions, type utilities, and helper APIs</li>
<li><strong><a href="docs/adapters.md">Database Adapters</a></strong> - PostgreSQL and SQLite specifics, differences, limitations</li>
<li><strong><a href="docs/development.md">Development Guide</a></strong> - Contributing, testing, troubleshooting</li>
</ul>
<h2 id="packages" tabindex="-1"><a class="anchor" href="#packages" aria-hidden="true">#</a> Packages</h2>
<table>
<thead>
<tr>
<th>Package</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@tinqerjs/tinqer</code></td>
<td>Core expression tree and types (re-exported by adapters)</td>
</tr>
<tr>
<td><code>@tinqerjs/pg-promise-adapter</code></td>
<td>PostgreSQL adapter with pg-promise</td>
</tr>
<tr>
<td><code>@tinqerjs/better-sqlite3-adapter</code></td>
<td>SQLite adapter with better-sqlite3</td>
</tr>
</tbody>
</table>
<h2 id="credits" tabindex="-1"><a class="anchor" href="#credits" aria-hidden="true">#</a> Credits</h2>
<p>Tinqer uses <a href="https://oxc.rs/">OXC</a> - a fast JavaScript/TypeScript parser written in Rust - to parse lambda expressions at runtime. OXC’s speed and reliability make Tinqer’s runtime lambda parsing practical and performant.</p>
<h2 id="for-ai%2Fllms" tabindex="-1"><a class="anchor" href="#for-ai%2Fllms" aria-hidden="true">#</a> For AI/LLMs</h2>
<p>A consolidated documentation file for AI assistants is available at <a href="llms.txt"><code>llms.txt</code></a>. This file includes all documentation in a single text format optimized for Large Language Model consumption.</p>
<h2 id="license" tabindex="-1"><a class="anchor" href="#license" aria-hidden="true">#</a> License</h2>
<p>MIT</p>

      </article>

      <nav class="toc">
<h2>On This Page</h2>
<ul>
  <li><a href="#installation">Installation</a></li>
  <li><a href="#quick-start">Quick Start</a></li>
  <li class="toc-sub"><a href="#postgresql-example">PostgreSQL Example</a></li>
  <li class="toc-sub"><a href="#sql-generation-without-execution">SQL Generation Without Execution</a></li>
  <li><a href="#core-features">Core Features</a></li>
  <li class="toc-sub"><a href="#type-safe-query-building">Type-Safe Query Building</a></li>
  <li class="toc-sub"><a href="#query-composition">Query Composition</a></li>
  <li class="toc-sub"><a href="#row-filters">Row Filters</a></li>
  <li class="toc-sub"><a href="#joins">Joins</a></li>
  <li class="toc-sub"><a href="#grouping-and-aggregation">Grouping and Aggregation</a></li>
  <li class="toc-sub"><a href="#window-functions">Window Functions</a></li>
  <li class="toc-sub"><a href="#crud-operations">CRUD Operations</a></li>
  <li class="toc-sub"><a href="#parameters-and-auto-parameterisation">Parameters and Auto-Parameterisation</a></li>
  <li class="toc-sub"><a href="#case-insensitive-string-operations">Case-Insensitive String Operations</a></li>
  <li><a href="#key-concepts">Key Concepts</a></li>
  <li class="toc-sub"><a href="#query-lifecycle">Query Lifecycle</a></li>
  <li class="toc-sub"><a href="#expression-support">Expression Support</a></li>
  <li><a href="#database-support">Database Support</a></li>
  <li class="toc-sub"><a href="#postgresql">PostgreSQL</a></li>
  <li class="toc-sub"><a href="#sqlite">SQLite</a></li>
  <li><a href="#differences-from-net-linq-to-sql">Differences from .NET LINQ to SQL</a></li>
  <li><a href="#documentation">Documentation</a></li>
  <li><a href="#packages">Packages</a></li>
  <li><a href="#credits">Credits</a></li>
  <li><a href="#for-ai%2Fllms">For AI/LLMs</a></li>
  <li><a href="#license">License</a></li>
</ul>
</nav>
    </div>

    <footer class="page-nav">
  <span></span>
  <a href="guide.html" class="next">Guide →</a>
</footer>
  </main>

  <!-- Mobile Menu Script -->
  <script>
    (function() {
      const hamburger = document.getElementById('hamburger');
      const sidebar = document.getElementById('sidebar');
      const overlay = document.getElementById('overlay');

      function toggleMenu() {
        hamburger.classList.toggle('active');
        sidebar.classList.toggle('mobile-open');
        overlay.classList.toggle('active');
        document.body.style.overflow = sidebar.classList.contains('mobile-open') ? 'hidden' : '';
      }

      function closeMenu() {
        hamburger.classList.remove('active');
        sidebar.classList.remove('mobile-open');
        overlay.classList.remove('active');
        document.body.style.overflow = '';
      }

      hamburger.addEventListener('click', toggleMenu);
      overlay.addEventListener('click', closeMenu);

      // Close menu when clicking a nav link
      const navLinks = sidebar.querySelectorAll('.nav-list a');
      navLinks.forEach(link => {
        link.addEventListener('click', closeMenu);
      });

      // Close menu on escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && sidebar.classList.contains('mobile-open')) {
          closeMenu();
        }
      });
    })();
  </script>
</body>
</html>
